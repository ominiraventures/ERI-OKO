/*
 * Copyright(c) 2009 - 2019 Abelium d.o.o.
 * Kajuhova 90, 1000 Ljubljana, Slovenia
 * All rights reserved
 * Copyright(c) 1995 - 2018 T-Systems Multimedia Solutions GmbH
 * Riesaer Str. 5, 01129 Dresden
 * All rights reserved.
 *
 * INATrace Services API
 * INATrace Services API OpenAPI documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the openapi-typescript-angular-generator.
 * https://github.com/alenabelium/openapi-typescript-angular-generator
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { ValidatorFn, Validators } from '@angular/forms';

import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { catchError }                                        from 'rxjs/operators';

import { ApiBaseEntity } from '../model/apiBaseEntity';
import { ApiDefaultResponse } from '../model/apiDefaultResponse';
import { ApiFinalProduct } from '../model/apiFinalProduct';
import { ApiKnowledgeBlog } from '../model/apiKnowledgeBlog';
import { ApiPaginatedResponseApiFinalProduct } from '../model/apiPaginatedResponseApiFinalProduct';
import { ApiPaginatedResponseApiKnowledgeBlogBase } from '../model/apiPaginatedResponseApiKnowledgeBlogBase';
import { ApiPaginatedResponseApiProductLabelBatch } from '../model/apiPaginatedResponseApiProductLabelBatch';
import { ApiPaginatedResponseApiProductListResponse } from '../model/apiPaginatedResponseApiProductListResponse';
import { ApiProduct } from '../model/apiProduct';
import { ApiProductLabel } from '../model/apiProductLabel';
import { ApiProductLabelBatch } from '../model/apiProductLabelBatch';
import { ApiProductLabelCompanyDocument } from '../model/apiProductLabelCompanyDocument';
import { ApiProductLabelContent } from '../model/apiProductLabelContent';
import { ApiProductLabelUpdateValues } from '../model/apiProductLabelUpdateValues';
import { ApiResponseApiBaseEntity } from '../model/apiResponseApiBaseEntity';
import { ApiResponseApiFinalProduct } from '../model/apiResponseApiFinalProduct';
import { ApiResponseApiKnowledgeBlog } from '../model/apiResponseApiKnowledgeBlog';
import { ApiResponseApiProduct } from '../model/apiResponseApiProduct';
import { ApiResponseApiProductLabel } from '../model/apiResponseApiProductLabel';
import { ApiResponseApiProductLabelAnalytics } from '../model/apiResponseApiProductLabelAnalytics';
import { ApiResponseApiProductLabelBatch } from '../model/apiResponseApiProductLabelBatch';
import { ApiResponseApiProductLabelContent } from '../model/apiResponseApiProductLabelContent';
import { ApiResponseApiProductLabelValues } from '../model/apiResponseApiProductLabelValues';
import { ApiResponseListApiProductLabelBase } from '../model/apiResponseListApiProductLabelBase';
import { ApiResponseListApiProductLabelCompanyDocument } from '../model/apiResponseListApiProductLabelCompanyDocument';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/**
 * Namespace for addProductKnowledgeBlog.
 */
export namespace AddProductKnowledgeBlog {
    /**
     * Parameter map for addProductKnowledgeBlog.
     */
    export interface PartialParamMap {
      /**
       * type
       */
      productId: number;
      ApiKnowledgeBlog: ApiKnowledgeBlog;
    }

    /**
     * Enumeration of all parameters for addProductKnowledgeBlog.
     */
    export enum Parameters {
      /**
       * type
       */
      productId = 'productId',
      ApiKnowledgeBlog = 'ApiKnowledgeBlog'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of addProductKnowledgeBlog
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof AddProductKnowledgeBlog.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for createOrUpdateFinalProduct.
 */
export namespace CreateOrUpdateFinalProduct {
    /**
     * Parameter map for createOrUpdateFinalProduct.
     */
    export interface PartialParamMap {
      /**
       * Product ID
       */
      productId: number;
      ApiFinalProduct: ApiFinalProduct;
    }

    /**
     * Enumeration of all parameters for createOrUpdateFinalProduct.
     */
    export enum Parameters {
      /**
       * Product ID
       */
      productId = 'productId',
      ApiFinalProduct = 'ApiFinalProduct'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createOrUpdateFinalProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateOrUpdateFinalProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for createProduct.
 */
export namespace CreateProduct {
    /**
     * Parameter map for createProduct.
     */
    export interface PartialParamMap {
      ApiProduct: ApiProduct;
    }

    /**
     * Enumeration of all parameters for createProduct.
     */
    export enum Parameters {
      ApiProduct = 'ApiProduct'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for createProductLabel.
 */
export namespace CreateProductLabel {
    /**
     * Parameter map for createProductLabel.
     */
    export interface PartialParamMap {
      ApiProductLabel: ApiProductLabel;
    }

    /**
     * Enumeration of all parameters for createProductLabel.
     */
    export enum Parameters {
      ApiProductLabel = 'ApiProductLabel'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for createProductLabelBatch.
 */
export namespace CreateProductLabelBatch {
    /**
     * Parameter map for createProductLabelBatch.
     */
    export interface PartialParamMap {
      ApiProductLabelBatch: ApiProductLabelBatch;
    }

    /**
     * Enumeration of all parameters for createProductLabelBatch.
     */
    export enum Parameters {
      ApiProductLabelBatch = 'ApiProductLabelBatch'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProductLabelBatch
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProductLabelBatch.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteFinalProduct.
 */
export namespace DeleteFinalProduct {
    /**
     * Parameter map for deleteFinalProduct.
     */
    export interface PartialParamMap {
      /**
       * Product ID
       */
      productId: number;
      /**
       * Final product ID
       */
      finalProductId: number;
    }

    /**
     * Enumeration of all parameters for deleteFinalProduct.
     */
    export enum Parameters {
      /**
       * Product ID
       */
      productId = 'productId',
      /**
       * Final product ID
       */
      finalProductId = 'finalProductId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteFinalProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteFinalProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      finalProductId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProduct.
 */
export namespace DeleteProduct {
    /**
     * Parameter map for deleteProduct.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProduct.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabel.
 */
export namespace DeleteProductLabel {
    /**
     * Parameter map for deleteProductLabel.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabel.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabelBatch.
 */
export namespace DeleteProductLabelBatch {
    /**
     * Parameter map for deleteProductLabelBatch.
     */
    export interface PartialParamMap {
      /**
       * Batch id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabelBatch.
     */
    export enum Parameters {
      /**
       * Batch id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabelBatch
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabelBatch.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabelFeedback.
 */
export namespace DeleteProductLabelFeedback {
    /**
     * Parameter map for deleteProductLabelFeedback.
     */
    export interface PartialParamMap {
      /**
       * Feedback id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabelFeedback.
     */
    export enum Parameters {
      /**
       * Feedback id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabelFeedback
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabelFeedback.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for executeProductAction.
 */
export namespace ExecuteProductAction {
    /**
     * Parameter map for executeProductAction.
     */
    export interface PartialParamMap {
      action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL';
      ApiBaseEntity: ApiBaseEntity;
    }

    /**
     * Enumeration of all parameters for executeProductAction.
     */
    export enum Parameters {
      action = 'action',
      ApiBaseEntity = 'ApiBaseEntity'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of executeProductAction
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ExecuteProductAction.PartialParamMap]?: [string, ValidatorFn][]} = {
      action: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getCompanyDocumentsForProductLabel.
 */
export namespace GetCompanyDocumentsForProductLabel {
    /**
     * Parameter map for getCompanyDocumentsForProductLabel.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getCompanyDocumentsForProductLabel.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getCompanyDocumentsForProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetCompanyDocumentsForProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getFinalProduct.
 */
export namespace GetFinalProduct {
    /**
     * Parameter map for getFinalProduct.
     */
    export interface PartialParamMap {
      /**
       * Product ID
       */
      productId: number;
      /**
       * Final product ID
       */
      finalProductId: number;
    }

    /**
     * Enumeration of all parameters for getFinalProduct.
     */
    export enum Parameters {
      /**
       * Product ID
       */
      productId = 'productId',
      /**
       * Final product ID
       */
      finalProductId = 'finalProductId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getFinalProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetFinalProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      finalProductId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getFinalProductLabels.
 */
export namespace GetFinalProductLabels {
    /**
     * Parameter map for getFinalProductLabels.
     */
    export interface PartialParamMap {
      /**
       * Product ID
       */
      productId: number;
      /**
       * Final product ID
       */
      finalProductId: number;
      /**
       * Also return the unpublished labels
       */
      returnUnpublished?: boolean;
    }

    /**
     * Enumeration of all parameters for getFinalProductLabels.
     */
    export enum Parameters {
      /**
       * Product ID
       */
      productId = 'productId',
      /**
       * Final product ID
       */
      finalProductId = 'finalProductId',
      /**
       * Also return the unpublished labels
       */
      returnUnpublished = 'returnUnpublished'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getFinalProductLabels
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetFinalProductLabels.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      finalProductId: [
              ['required', Validators.required],
      ],
      returnUnpublished: [
      ],
    };
}

/**
 * Namespace for getFinalProductList.
 */
export namespace GetFinalProductList {
    /**
     * Parameter map for getFinalProductList.
     */
    export interface PartialParamMap {
      /**
       * Product ID
       */
      productId: number;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
    }

    /**
     * Enumeration of all parameters for getFinalProductList.
     */
    export enum Parameters {
      /**
       * Product ID
       */
      productId = 'productId',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getFinalProductList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetFinalProductList.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      requestType: [
      ],
      limit: [
              ['min', Validators.min(1)],
      ],
      offset: [
              ['min', Validators.min(0)],
      ],
      sortBy: [
      ],
      sort: [
      ],
    };
}

/**
 * Namespace for getProduct.
 */
export namespace GetProduct {
    /**
     * Parameter map for getProduct.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
      includeLabels?: boolean;
    }

    /**
     * Enumeration of all parameters for getProduct.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id',
      includeLabels = 'includeLabels'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
      includeLabels: [
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlog.
 */
export namespace GetProductKnowledgeBlog {
    /**
     * Parameter map for getProductKnowledgeBlog.
     */
    export interface PartialParamMap {
      /**
       * id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlog.
     */
    export enum Parameters {
      /**
       * id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlog
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlog.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlogs.
 */
export namespace GetProductKnowledgeBlogs {
    /**
     * Parameter map for getProductKnowledgeBlogs.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      productId: number;
      /**
       * knowledge blog type
       */
      type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE';
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlogs.
     */
    export enum Parameters {
      /**
       * Product id
       */
      productId = 'productId',
      /**
       * knowledge blog type
       */
      type = 'type',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlogs
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlogs.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      type: [
      ],
      requestType: [
      ],
      limit: [
              ['min', Validators.min(1)],
      ],
      offset: [
              ['min', Validators.min(0)],
      ],
      sortBy: [
      ],
      sort: [
      ],
    };
}

/**
 * Namespace for getProductLabel.
 */
export namespace GetProductLabel {
    /**
     * Parameter map for getProductLabel.
     */
    export interface PartialParamMap {
      /**
       * Record id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabel.
     */
    export enum Parameters {
      /**
       * Record id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelAnalytics.
 */
export namespace GetProductLabelAnalytics {
    /**
     * Parameter map for getProductLabelAnalytics.
     */
    export interface PartialParamMap {
      /**
       * Label uid
       */
      uid: string;
    }

    /**
     * Enumeration of all parameters for getProductLabelAnalytics.
     */
    export enum Parameters {
      /**
       * Label uid
       */
      uid = 'uid'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelAnalytics
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelAnalytics.PartialParamMap]?: [string, ValidatorFn][]} = {
      uid: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelBatch.
 */
export namespace GetProductLabelBatch {
    /**
     * Parameter map for getProductLabelBatch.
     */
    export interface PartialParamMap {
      /**
       * Batch id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelBatch.
     */
    export enum Parameters {
      /**
       * Batch id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelBatch
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelBatch.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelBatches.
 */
export namespace GetProductLabelBatches {
    /**
     * Parameter map for getProductLabelBatches.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
      /**
       * Batch number (start of it)
       */
      number?: string;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
    }

    /**
     * Enumeration of all parameters for getProductLabelBatches.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id',
      /**
       * Batch number (start of it)
       */
      number = 'number',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelBatches
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelBatches.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
      number: [
      ],
      requestType: [
      ],
      limit: [
              ['min', Validators.min(1)],
      ],
      offset: [
              ['min', Validators.min(0)],
      ],
      sortBy: [
      ],
      sort: [
      ],
    };
}

/**
 * Namespace for getProductLabelContent.
 */
export namespace GetProductLabelContent {
    /**
     * Parameter map for getProductLabelContent.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelContent.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelContent
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelContent.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelInstructions.
 */
export namespace GetProductLabelInstructions {
    /**
     * Parameter map for getProductLabelInstructions.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelInstructions.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelInstructions
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelInstructions.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelValues.
 */
export namespace GetProductLabelValues {
    /**
     * Parameter map for getProductLabelValues.
     */
    export interface PartialParamMap {
      /**
       * Record id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelValues.
     */
    export enum Parameters {
      /**
       * Record id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelValues
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelValues.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabels.
 */
export namespace GetProductLabels {
    /**
     * Parameter map for getProductLabels.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabels.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabels
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabels.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for listProducts.
 */
export namespace ListProducts {
    /**
     * Parameter map for listProducts.
     */
    export interface PartialParamMap {
      /**
       * Product name (start of name)
       */
      name?: string;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      language?: 'EN' | 'DE' | 'RW' | 'ES';
    }

    /**
     * Enumeration of all parameters for listProducts.
     */
    export enum Parameters {
      /**
       * Product name (start of name)
       */
      name = 'name',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      language = 'language'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listProducts
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListProducts.PartialParamMap]?: [string, ValidatorFn][]} = {
      name: [
      ],
      requestType: [
      ],
      limit: [
              ['min', Validators.min(1)],
      ],
      offset: [
              ['min', Validators.min(0)],
      ],
      sortBy: [
      ],
      sort: [
      ],
      language: [
      ],
    };
}

/**
 * Namespace for listProductsAdmin.
 */
export namespace ListProductsAdmin {
    /**
     * Parameter map for listProductsAdmin.
     */
    export interface PartialParamMap {
      /**
       * Product name (start of name)
       */
      name?: string;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
    }

    /**
     * Enumeration of all parameters for listProductsAdmin.
     */
    export enum Parameters {
      /**
       * Product name (start of name)
       */
      name = 'name',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listProductsAdmin
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListProductsAdmin.PartialParamMap]?: [string, ValidatorFn][]} = {
      name: [
      ],
      requestType: [
      ],
      limit: [
              ['min', Validators.min(1)],
      ],
      offset: [
              ['min', Validators.min(0)],
      ],
      sortBy: [
      ],
      sort: [
      ],
    };
}

/**
 * Namespace for updateCompanyDocumentsForProductLabel.
 */
export namespace UpdateCompanyDocumentsForProductLabel {
    /**
     * Parameter map for updateCompanyDocumentsForProductLabel.
     */
    export interface PartialParamMap {
      /**
       * Label ID
       */
      id: number;
      ApiProductLabelCompanyDocument: Array<ApiProductLabelCompanyDocument>;
    }

    /**
     * Enumeration of all parameters for updateCompanyDocumentsForProductLabel.
     */
    export enum Parameters {
      /**
       * Label ID
       */
      id = 'id',
      ApiProductLabelCompanyDocument = 'ApiProductLabelCompanyDocument'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateCompanyDocumentsForProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateCompanyDocumentsForProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
      ApiProductLabelCompanyDocument: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for updateProduct.
 */
export namespace UpdateProduct {
    /**
     * Parameter map for updateProduct.
     */
    export interface PartialParamMap {
      ApiProduct: ApiProduct;
    }

    /**
     * Enumeration of all parameters for updateProduct.
     */
    export enum Parameters {
      ApiProduct = 'ApiProduct'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProduct
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProduct.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductKnowledgeBlog.
 */
export namespace UpdateProductKnowledgeBlog {
    /**
     * Parameter map for updateProductKnowledgeBlog.
     */
    export interface PartialParamMap {
      ApiKnowledgeBlog: ApiKnowledgeBlog;
    }

    /**
     * Enumeration of all parameters for updateProductKnowledgeBlog.
     */
    export enum Parameters {
      ApiKnowledgeBlog = 'ApiKnowledgeBlog'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductKnowledgeBlog
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductKnowledgeBlog.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabel.
 */
export namespace UpdateProductLabel {
    /**
     * Parameter map for updateProductLabel.
     */
    export interface PartialParamMap {
      ApiProductLabel: ApiProductLabel;
    }

    /**
     * Enumeration of all parameters for updateProductLabel.
     */
    export enum Parameters {
      ApiProductLabel = 'ApiProductLabel'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabel
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabel.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelBatch.
 */
export namespace UpdateProductLabelBatch {
    /**
     * Parameter map for updateProductLabelBatch.
     */
    export interface PartialParamMap {
      ApiProductLabelBatch: ApiProductLabelBatch;
    }

    /**
     * Enumeration of all parameters for updateProductLabelBatch.
     */
    export enum Parameters {
      ApiProductLabelBatch = 'ApiProductLabelBatch'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelBatch
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelBatch.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelContent.
 */
export namespace UpdateProductLabelContent {
    /**
     * Parameter map for updateProductLabelContent.
     */
    export interface PartialParamMap {
      ApiProductLabelContent: ApiProductLabelContent;
    }

    /**
     * Enumeration of all parameters for updateProductLabelContent.
     */
    export enum Parameters {
      ApiProductLabelContent = 'ApiProductLabelContent'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelContent
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelContent.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelValues.
 */
export namespace UpdateProductLabelValues {
    /**
     * Parameter map for updateProductLabelValues.
     */
    export interface PartialParamMap {
      ApiProductLabelUpdateValues: ApiProductLabelUpdateValues;
    }

    /**
     * Enumeration of all parameters for updateProductLabelValues.
     */
    export enum Parameters {
      ApiProductLabelUpdateValues = 'ApiProductLabelUpdateValues'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelValues
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelValues.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}



@Injectable({
  providedIn: 'root'
})
export class ProductControllerService {

    protected basePath = 'http://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath != null ? configuration.basePath : (basePath != null ? basePath : this.basePath);
        } else {
            this.configuration.basePath = basePath != null ? basePath : this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }



  /**
   * Add knowledge blog to a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addProductKnowledgeBlogByMap(
    map: AddProductKnowledgeBlog.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public addProductKnowledgeBlogByMap(
    map: AddProductKnowledgeBlog.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public addProductKnowledgeBlogByMap(
    map: AddProductKnowledgeBlog.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public addProductKnowledgeBlogByMap(
    map: AddProductKnowledgeBlog.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.addProductKnowledgeBlog(
      map.productId,
      map.ApiKnowledgeBlog,
      observe,
      reportProgress
    );
  }


    /**
     * Add knowledge blog to a product
     * 
     * @param productId type
     * @param ApiKnowledgeBlog 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addProductKnowledgeBlog(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public addProductKnowledgeBlog(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public addProductKnowledgeBlog(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public addProductKnowledgeBlog(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling addProductKnowledgeBlog.');
        }
        if (ApiKnowledgeBlog === null || ApiKnowledgeBlog === undefined) {
            throw new Error('Required parameter ApiKnowledgeBlog was null or undefined when calling addProductKnowledgeBlog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/knowledgeBlog/${encodeURIComponent(String(productId))}`,
            ApiKnowledgeBlog,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'addProductKnowledgeBlog')));
        }
        return handle;
    }


  /**
   * Create or update final product. by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createOrUpdateFinalProductByMap(
    map: CreateOrUpdateFinalProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createOrUpdateFinalProductByMap(
    map: CreateOrUpdateFinalProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createOrUpdateFinalProductByMap(
    map: CreateOrUpdateFinalProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createOrUpdateFinalProductByMap(
    map: CreateOrUpdateFinalProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createOrUpdateFinalProduct(
      map.productId,
      map.ApiFinalProduct,
      observe,
      reportProgress
    );
  }


    /**
     * Create or update final product.
     * 
     * @param productId Product ID
     * @param ApiFinalProduct 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdateFinalProduct(productId: number, ApiFinalProduct: ApiFinalProduct, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createOrUpdateFinalProduct(productId: number, ApiFinalProduct: ApiFinalProduct, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createOrUpdateFinalProduct(productId: number, ApiFinalProduct: ApiFinalProduct, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createOrUpdateFinalProduct(productId: number, ApiFinalProduct: ApiFinalProduct, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling createOrUpdateFinalProduct.');
        }
        if (ApiFinalProduct === null || ApiFinalProduct === undefined) {
            throw new Error('Required parameter ApiFinalProduct was null or undefined when calling createOrUpdateFinalProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(productId))}/finalProduct`,
            ApiFinalProduct,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createOrUpdateFinalProduct')));
        }
        return handle;
    }


  /**
   * Create a new product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductByMap(
    map: CreateProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductByMap(
    map: CreateProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductByMap(
    map: CreateProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductByMap(
    map: CreateProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProduct(
      map.ApiProduct,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product
     * 
     * @param ApiProduct 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProduct(ApiProduct: ApiProduct, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProduct(ApiProduct: ApiProduct, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProduct(ApiProduct: ApiProduct, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProduct(ApiProduct: ApiProduct, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProduct === null || ApiProduct === undefined) {
            throw new Error('Required parameter ApiProduct was null or undefined when calling createProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/create`,
            ApiProduct,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProduct')));
        }
        return handle;
    }


  /**
   * Create a new product label by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductLabelByMap(
    map: CreateProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductLabelByMap(
    map: CreateProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductLabelByMap(
    map: CreateProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductLabelByMap(
    map: CreateProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProductLabel(
      map.ApiProductLabel,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product label
     * 
     * @param ApiProductLabel 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProductLabel(ApiProductLabel: ApiProductLabel, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabel === null || ApiProductLabel === undefined) {
            throw new Error('Required parameter ApiProductLabel was null or undefined when calling createProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/label/create`,
            ApiProductLabel,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProductLabel')));
        }
        return handle;
    }


  /**
   * Create a new product label batch by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductLabelBatchByMap(
    map: CreateProductLabelBatch.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductLabelBatchByMap(
    map: CreateProductLabelBatch.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductLabelBatchByMap(
    map: CreateProductLabelBatch.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductLabelBatchByMap(
    map: CreateProductLabelBatch.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProductLabelBatch(
      map.ApiProductLabelBatch,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product label batch
     * 
     * @param ApiProductLabelBatch 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelBatch === null || ApiProductLabelBatch === undefined) {
            throw new Error('Required parameter ApiProductLabelBatch was null or undefined when calling createProductLabelBatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/label_batch/create`,
            ApiProductLabelBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProductLabelBatch')));
        }
        return handle;
    }


  /**
   * Delete a final product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteFinalProductByMap(
    map: DeleteFinalProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteFinalProductByMap(
    map: DeleteFinalProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteFinalProductByMap(
    map: DeleteFinalProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteFinalProductByMap(
    map: DeleteFinalProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteFinalProduct(
      map.productId,
      map.finalProductId,
      observe,
      reportProgress
    );
  }


    /**
     * Delete a final product
     * 
     * @param productId Product ID
     * @param finalProductId Final product ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFinalProduct(productId: number, finalProductId: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteFinalProduct(productId: number, finalProductId: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteFinalProduct(productId: number, finalProductId: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteFinalProduct(productId: number, finalProductId: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling deleteFinalProduct.');
        }
        if (finalProductId === null || finalProductId === undefined) {
            throw new Error('Required parameter finalProductId was null or undefined when calling deleteFinalProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(productId))}/finalProduct/${encodeURIComponent(String(finalProductId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteFinalProduct')));
        }
        return handle;
    }


  /**
   * Deletes a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductByMap(
    map: DeleteProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductByMap(
    map: DeleteProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductByMap(
    map: DeleteProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductByMap(
    map: DeleteProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProduct(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product
     * 
     * @param id Product id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProduct(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProduct(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProduct(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProduct(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProduct')));
        }
        return handle;
    }


  /**
   * Deletes a product label by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelByMap(
    map: DeleteProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelByMap(
    map: DeleteProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelByMap(
    map: DeleteProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelByMap(
    map: DeleteProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabel(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabel(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabel(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabel(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabel(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabel')));
        }
        return handle;
    }


  /**
   * Deletes a product label batch by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelBatchByMap(
    map: DeleteProductLabelBatch.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelBatchByMap(
    map: DeleteProductLabelBatch.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelBatchByMap(
    map: DeleteProductLabelBatch.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelBatchByMap(
    map: DeleteProductLabelBatch.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabelBatch(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label batch
     * 
     * @param id Batch id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabelBatch(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabelBatch(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabelBatch(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabelBatch(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabelBatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label_batch/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabelBatch')));
        }
        return handle;
    }


  /**
   * Deletes a product label feedback by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelFeedbackByMap(
    map: DeleteProductLabelFeedback.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelFeedbackByMap(
    map: DeleteProductLabelFeedback.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelFeedbackByMap(
    map: DeleteProductLabelFeedback.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelFeedbackByMap(
    map: DeleteProductLabelFeedback.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabelFeedback(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label feedback
     * 
     * @param id Feedback id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabelFeedback(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabelFeedback(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabelFeedback(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabelFeedback(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabelFeedback.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/feedback/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabelFeedback')));
        }
        return handle;
    }


  /**
   * Execute action by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public executeProductActionByMap(
    map: ExecuteProductAction.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public executeProductActionByMap(
    map: ExecuteProductAction.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public executeProductActionByMap(
    map: ExecuteProductAction.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public executeProductActionByMap(
    map: ExecuteProductAction.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.executeProductAction(
      map.action,
      map.ApiBaseEntity,
      observe,
      reportProgress
    );
  }


    /**
     * Execute action
     * 
     * @param action 
     * @param ApiBaseEntity 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeProductAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public executeProductAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public executeProductAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public executeProductAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling executeProductAction.');
        }
        if (ApiBaseEntity === null || ApiBaseEntity === undefined) {
            throw new Error('Required parameter ApiBaseEntity was null or undefined when calling executeProductAction.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/execute/${encodeURIComponent(String(action))}`,
            ApiBaseEntity,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'executeProductAction')));
        }
        return handle;
    }


  /**
   * Get selected company documents for product label by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCompanyDocumentsForProductLabelByMap(
    map: GetCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseListApiProductLabelCompanyDocument>;
  public getCompanyDocumentsForProductLabelByMap(
    map: GetCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseListApiProductLabelCompanyDocument>>;
  public getCompanyDocumentsForProductLabelByMap(
    map: GetCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseListApiProductLabelCompanyDocument>>;
  public getCompanyDocumentsForProductLabelByMap(
    map: GetCompanyDocumentsForProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getCompanyDocumentsForProductLabel(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get selected company documents for product label
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompanyDocumentsForProductLabel(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseListApiProductLabelCompanyDocument>;
    public getCompanyDocumentsForProductLabel(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseListApiProductLabelCompanyDocument>>;
    public getCompanyDocumentsForProductLabel(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseListApiProductLabelCompanyDocument>>;
    public getCompanyDocumentsForProductLabel(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCompanyDocumentsForProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseListApiProductLabelCompanyDocument>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/documents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getCompanyDocumentsForProductLabel')));
        }
        return handle;
    }


  /**
   * Get final product by ID. by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFinalProductByMap(
    map: GetFinalProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiFinalProduct>;
  public getFinalProductByMap(
    map: GetFinalProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiFinalProduct>>;
  public getFinalProductByMap(
    map: GetFinalProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiFinalProduct>>;
  public getFinalProductByMap(
    map: GetFinalProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getFinalProduct(
      map.productId,
      map.finalProductId,
      observe,
      reportProgress
    );
  }


    /**
     * Get final product by ID.
     * 
     * @param productId Product ID
     * @param finalProductId Final product ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalProduct(productId: number, finalProductId: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiFinalProduct>;
    public getFinalProduct(productId: number, finalProductId: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiFinalProduct>>;
    public getFinalProduct(productId: number, finalProductId: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiFinalProduct>>;
    public getFinalProduct(productId: number, finalProductId: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getFinalProduct.');
        }
        if (finalProductId === null || finalProductId === undefined) {
            throw new Error('Required parameter finalProductId was null or undefined when calling getFinalProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiFinalProduct>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(productId))}/finalProduct/${encodeURIComponent(String(finalProductId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getFinalProduct')));
        }
        return handle;
    }


  /**
   * Get final product labels. by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFinalProductLabelsByMap(
    map: GetFinalProductLabels.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseListApiProductLabelBase>;
  public getFinalProductLabelsByMap(
    map: GetFinalProductLabels.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
  public getFinalProductLabelsByMap(
    map: GetFinalProductLabels.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
  public getFinalProductLabelsByMap(
    map: GetFinalProductLabels.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getFinalProductLabels(
      map.productId,
      map.finalProductId,
      map.returnUnpublished,
      observe,
      reportProgress
    );
  }


    /**
     * Get final product labels.
     * 
     * @param productId Product ID
     * @param finalProductId Final product ID
     * @param returnUnpublished Also return the unpublished labels
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalProductLabels(productId: number, finalProductId: number, returnUnpublished?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseListApiProductLabelBase>;
    public getFinalProductLabels(productId: number, finalProductId: number, returnUnpublished?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
    public getFinalProductLabels(productId: number, finalProductId: number, returnUnpublished?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
    public getFinalProductLabels(productId: number, finalProductId: number, returnUnpublished?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getFinalProductLabels.');
        }
        if (finalProductId === null || finalProductId === undefined) {
            throw new Error('Required parameter finalProductId was null or undefined when calling getFinalProductLabels.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (returnUnpublished !== undefined && returnUnpublished !== null) {
            queryParameters = queryParameters.set('returnUnpublished', <any>returnUnpublished);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseListApiProductLabelBase>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(productId))}/finalProduct/${encodeURIComponent(String(finalProductId))}/labels`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getFinalProductLabels')));
        }
        return handle;
    }


  /**
   * Get final product list by product ID. by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFinalProductListByMap(
    map: GetFinalProductList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiFinalProduct>;
  public getFinalProductListByMap(
    map: GetFinalProductList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiFinalProduct>>;
  public getFinalProductListByMap(
    map: GetFinalProductList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiFinalProduct>>;
  public getFinalProductListByMap(
    map: GetFinalProductList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getFinalProductList(
      map.productId,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      observe,
      reportProgress
    );
  }


    /**
     * Get final product list by product ID.
     * 
     * @param productId Product ID
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFinalProductList(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiFinalProduct>;
    public getFinalProductList(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiFinalProduct>>;
    public getFinalProductList(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiFinalProduct>>;
    public getFinalProductList(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getFinalProductList.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiFinalProduct>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(productId))}/finalProduct/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getFinalProductList')));
        }
        return handle;
    }


  /**
   * Get all info about a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductByMap(
    map: GetProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProduct>;
  public getProductByMap(
    map: GetProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProduct>>;
  public getProductByMap(
    map: GetProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProduct>>;
  public getProductByMap(
    map: GetProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProduct(
      map.id,
      map.includeLabels,
      observe,
      reportProgress
    );
  }


    /**
     * Get all info about a product
     * 
     * @param id Product id
     * @param includeLabels 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProduct(id: number, includeLabels?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProduct>;
    public getProduct(id: number, includeLabels?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProduct>>;
    public getProduct(id: number, includeLabels?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProduct>>;
    public getProduct(id: number, includeLabels?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProduct.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeLabels !== undefined && includeLabels !== null) {
            queryParameters = queryParameters.set('includeLabels', <any>includeLabels);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProduct>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProduct')));
        }
        return handle;
    }


  /**
   * Get knowledge blog by id by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiKnowledgeBlog>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiKnowledgeBlog>>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiKnowledgeBlog>>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlog(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get knowledge blog by id
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlog(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiKnowledgeBlog>;
    public getProductKnowledgeBlog(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiKnowledgeBlog>>;
    public getProductKnowledgeBlog(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiKnowledgeBlog>>;
    public getProductKnowledgeBlog(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductKnowledgeBlog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiKnowledgeBlog>(`${this.configuration.basePath}/api/product/knowledgeBlog/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlog')));
        }
        return handle;
    }


  /**
   * Get knowledge blogs for a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogsByMap(
    map: GetProductKnowledgeBlogs.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiKnowledgeBlogBase>;
  public getProductKnowledgeBlogsByMap(
    map: GetProductKnowledgeBlogs.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiKnowledgeBlogBase>>;
  public getProductKnowledgeBlogsByMap(
    map: GetProductKnowledgeBlogs.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiKnowledgeBlogBase>>;
  public getProductKnowledgeBlogsByMap(
    map: GetProductKnowledgeBlogs.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlogs(
      map.productId,
      map.type,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      observe,
      reportProgress
    );
  }


    /**
     * Get knowledge blogs for a product
     * 
     * @param productId Product id
     * @param type knowledge blog type
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlogs(productId: number, type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiKnowledgeBlogBase>;
    public getProductKnowledgeBlogs(productId: number, type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiKnowledgeBlogBase>>;
    public getProductKnowledgeBlogs(productId: number, type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiKnowledgeBlogBase>>;
    public getProductKnowledgeBlogs(productId: number, type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductKnowledgeBlogs.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', <any>type);
        }
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiKnowledgeBlogBase>(`${this.configuration.basePath}/api/product/knowledgeBlog/list/${encodeURIComponent(String(productId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlogs')));
        }
        return handle;
    }


  /**
   * Get label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelByMap(
    map: GetProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabel>;
  public getProductLabelByMap(
    map: GetProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabel>>;
  public getProductLabelByMap(
    map: GetProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabel>>;
  public getProductLabelByMap(
    map: GetProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabel(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label data
     * 
     * @param id Record id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabel(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabel>;
    public getProductLabel(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabel>>;
    public getProductLabel(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabel>>;
    public getProductLabel(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabel>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabel')));
        }
        return handle;
    }


  /**
   * Get label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelAnalyticsByMap(
    map: GetProductLabelAnalytics.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelAnalytics>;
  public getProductLabelAnalyticsByMap(
    map: GetProductLabelAnalytics.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelAnalytics>>;
  public getProductLabelAnalyticsByMap(
    map: GetProductLabelAnalytics.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelAnalytics>>;
  public getProductLabelAnalyticsByMap(
    map: GetProductLabelAnalytics.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelAnalytics(
      map.uid,
      observe,
      reportProgress
    );
  }


    /**
     * Get label data
     * 
     * @param uid Label uid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelAnalytics(uid: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelAnalytics>;
    public getProductLabelAnalytics(uid: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelAnalytics>>;
    public getProductLabelAnalytics(uid: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelAnalytics>>;
    public getProductLabelAnalytics(uid: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling getProductLabelAnalytics.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelAnalytics>(`${this.configuration.basePath}/api/product/label/analytics/${encodeURIComponent(String(uid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelAnalytics')));
        }
        return handle;
    }


  /**
   * Get label batch data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelBatchByMap(
    map: GetProductLabelBatch.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelBatch>;
  public getProductLabelBatchByMap(
    map: GetProductLabelBatch.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelBatch>>;
  public getProductLabelBatchByMap(
    map: GetProductLabelBatch.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelBatch>>;
  public getProductLabelBatchByMap(
    map: GetProductLabelBatch.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelBatch(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label batch data
     * 
     * @param id Batch id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelBatch(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelBatch>;
    public getProductLabelBatch(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelBatch>>;
    public getProductLabelBatch(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelBatch>>;
    public getProductLabelBatch(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelBatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelBatch>(`${this.configuration.basePath}/api/product/label_batch/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelBatch')));
        }
        return handle;
    }


  /**
   * Get label batches for specified label. Sorting: number or productionDate, expiryDate by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelBatchesByMap(
    map: GetProductLabelBatches.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductLabelBatch>;
  public getProductLabelBatchesByMap(
    map: GetProductLabelBatches.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductLabelBatch>>;
  public getProductLabelBatchesByMap(
    map: GetProductLabelBatches.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductLabelBatch>>;
  public getProductLabelBatchesByMap(
    map: GetProductLabelBatches.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelBatches(
      map.id,
      map.number,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      observe,
      reportProgress
    );
  }


    /**
     * Get label batches for specified label. Sorting: number or productionDate, expiryDate
     * 
     * @param id Label id
     * @param number Batch number (start of it)
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelBatches(id: number, number?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductLabelBatch>;
    public getProductLabelBatches(id: number, number?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductLabelBatch>>;
    public getProductLabelBatches(id: number, number?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductLabelBatch>>;
    public getProductLabelBatches(id: number, number?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelBatches.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (number !== undefined && number !== null) {
            queryParameters = queryParameters.set('number', <any>number);
        }
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductLabelBatch>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/batches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelBatches')));
        }
        return handle;
    }


  /**
   * Get label content by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelContentByMap(
    map: GetProductLabelContent.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelContent>;
  public getProductLabelContentByMap(
    map: GetProductLabelContent.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelContent>>;
  public getProductLabelContentByMap(
    map: GetProductLabelContent.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelContent>>;
  public getProductLabelContentByMap(
    map: GetProductLabelContent.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelContent(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label content
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelContent(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelContent>;
    public getProductLabelContent(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelContent>>;
    public getProductLabelContent(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelContent>>;
    public getProductLabelContent(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelContent.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelContent>(`${this.configuration.basePath}/api/product/label/content/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelContent')));
        }
        return handle;
    }


  /**
   *  by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelInstructionsByMap(
    map: GetProductLabelInstructions.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<Blob>;
  public getProductLabelInstructionsByMap(
    map: GetProductLabelInstructions.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<Blob>>;
  public getProductLabelInstructionsByMap(
    map: GetProductLabelInstructions.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<Blob>>;
  public getProductLabelInstructionsByMap(
    map: GetProductLabelInstructions.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelInstructions(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelInstructions(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<Blob>;
    public getProductLabelInstructions(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<Blob>>;
    public getProductLabelInstructions(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<Blob>>;
    public getProductLabelInstructions(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelInstructions.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/instructions`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelInstructions')));
        }
        return handle;
    }


  /**
   * Get label with field values by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelValuesByMap(
    map: GetProductLabelValues.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelValues>;
  public getProductLabelValuesByMap(
    map: GetProductLabelValues.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelValues>>;
  public getProductLabelValuesByMap(
    map: GetProductLabelValues.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelValues>>;
  public getProductLabelValuesByMap(
    map: GetProductLabelValues.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelValues(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label with field values
     * 
     * @param id Record id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelValues(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelValues>;
    public getProductLabelValues(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelValues>>;
    public getProductLabelValues(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelValues>>;
    public getProductLabelValues(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelValues.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelValues>(`${this.configuration.basePath}/api/product/label/values/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelValues')));
        }
        return handle;
    }


  /**
   * Get labels for product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelsByMap(
    map: GetProductLabels.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseListApiProductLabelBase>;
  public getProductLabelsByMap(
    map: GetProductLabels.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
  public getProductLabelsByMap(
    map: GetProductLabels.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
  public getProductLabelsByMap(
    map: GetProductLabels.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabels(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get labels for product
     * 
     * @param id Product id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabels(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseListApiProductLabelBase>;
    public getProductLabels(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
    public getProductLabels(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
    public getProductLabels(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabels.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseListApiProductLabelBase>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(id))}/labels`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabels')));
        }
        return handle;
    }


  /**
   * Lists all products. Sorting: name or default by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listProductsByMap(
    map: ListProducts.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductListResponse>;
  public listProductsByMap(
    map: ListProducts.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsByMap(
    map: ListProducts.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsByMap(
    map: ListProducts.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listProducts(
      map.name,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.language,
      observe,
      reportProgress
    );
  }


    /**
     * Lists all products. Sorting: name or default
     * 
     * @param name Product name (start of name)
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param language 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProducts(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', language?: 'EN' | 'DE' | 'RW' | 'ES', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductListResponse>;
    public listProducts(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', language?: 'EN' | 'DE' | 'RW' | 'ES', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
    public listProducts(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', language?: 'EN' | 'DE' | 'RW' | 'ES', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
    public listProducts(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', language?: 'EN' | 'DE' | 'RW' | 'ES', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;
        if (language !== undefined && language !== null) {
            headers = headers.set('language', String(language));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductListResponse>(`${this.configuration.basePath}/api/product/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'listProducts')));
        }
        return handle;
    }


  /**
   * Lists all products. Must be admin. Sorting: name or default by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listProductsAdminByMap(
    map: ListProductsAdmin.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductListResponse>;
  public listProductsAdminByMap(
    map: ListProductsAdmin.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsAdminByMap(
    map: ListProductsAdmin.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsAdminByMap(
    map: ListProductsAdmin.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listProductsAdmin(
      map.name,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      observe,
      reportProgress
    );
  }


    /**
     * Lists all products. Must be admin. Sorting: name or default
     * 
     * @param name Product name (start of name)
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductsAdmin(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductListResponse>;
    public listProductsAdmin(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsAdmin(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsAdmin(name?: string, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductListResponse>(`${this.configuration.basePath}/api/product/admin/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'listProductsAdmin')));
        }
        return handle;
    }


  /**
   * Update company document product label list by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateCompanyDocumentsForProductLabelByMap(
    map: UpdateCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateCompanyDocumentsForProductLabelByMap(
    map: UpdateCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateCompanyDocumentsForProductLabelByMap(
    map: UpdateCompanyDocumentsForProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateCompanyDocumentsForProductLabelByMap(
    map: UpdateCompanyDocumentsForProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateCompanyDocumentsForProductLabel(
      map.id,
      map.ApiProductLabelCompanyDocument,
      observe,
      reportProgress
    );
  }


    /**
     * Update company document product label list
     * 
     * @param id Label ID
     * @param ApiProductLabelCompanyDocument 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateCompanyDocumentsForProductLabel(id: number, ApiProductLabelCompanyDocument: Array<ApiProductLabelCompanyDocument>, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateCompanyDocumentsForProductLabel(id: number, ApiProductLabelCompanyDocument: Array<ApiProductLabelCompanyDocument>, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateCompanyDocumentsForProductLabel(id: number, ApiProductLabelCompanyDocument: Array<ApiProductLabelCompanyDocument>, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateCompanyDocumentsForProductLabel(id: number, ApiProductLabelCompanyDocument: Array<ApiProductLabelCompanyDocument>, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCompanyDocumentsForProductLabel.');
        }
        if (ApiProductLabelCompanyDocument === null || ApiProductLabelCompanyDocument === undefined) {
            throw new Error('Required parameter ApiProductLabelCompanyDocument was null or undefined when calling updateCompanyDocumentsForProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/documents`,
            ApiProductLabelCompanyDocument,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateCompanyDocumentsForProductLabel')));
        }
        return handle;
    }


  /**
   * Update product data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductByMap(
    map: UpdateProduct.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductByMap(
    map: UpdateProduct.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductByMap(
    map: UpdateProduct.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductByMap(
    map: UpdateProduct.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProduct(
      map.ApiProduct,
      observe,
      reportProgress
    );
  }


    /**
     * Update product data
     * 
     * @param ApiProduct 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProduct(ApiProduct: ApiProduct, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProduct(ApiProduct: ApiProduct, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProduct(ApiProduct: ApiProduct, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProduct(ApiProduct: ApiProduct, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProduct === null || ApiProduct === undefined) {
            throw new Error('Required parameter ApiProduct was null or undefined when calling updateProduct.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/`,
            ApiProduct,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProduct')));
        }
        return handle;
    }


  /**
   * Update knowledge blog by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductKnowledgeBlogByMap(
    map: UpdateProductKnowledgeBlog.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductKnowledgeBlogByMap(
    map: UpdateProductKnowledgeBlog.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductKnowledgeBlogByMap(
    map: UpdateProductKnowledgeBlog.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductKnowledgeBlogByMap(
    map: UpdateProductKnowledgeBlog.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductKnowledgeBlog(
      map.ApiKnowledgeBlog,
      observe,
      reportProgress
    );
  }


    /**
     * Update knowledge blog
     * 
     * @param ApiKnowledgeBlog 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductKnowledgeBlog(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductKnowledgeBlog(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductKnowledgeBlog(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductKnowledgeBlog(ApiKnowledgeBlog: ApiKnowledgeBlog, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiKnowledgeBlog === null || ApiKnowledgeBlog === undefined) {
            throw new Error('Required parameter ApiKnowledgeBlog was null or undefined when calling updateProductKnowledgeBlog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/knowledgeBlog`,
            ApiKnowledgeBlog,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductKnowledgeBlog')));
        }
        return handle;
    }


  /**
   * Update label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelByMap(
    map: UpdateProductLabel.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelByMap(
    map: UpdateProductLabel.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelByMap(
    map: UpdateProductLabel.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelByMap(
    map: UpdateProductLabel.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabel(
      map.ApiProductLabel,
      observe,
      reportProgress
    );
  }


    /**
     * Update label data
     * 
     * @param ApiProductLabel 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabel(ApiProductLabel: ApiProductLabel, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabel(ApiProductLabel: ApiProductLabel, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabel === null || ApiProductLabel === undefined) {
            throw new Error('Required parameter ApiProductLabel was null or undefined when calling updateProductLabel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label`,
            ApiProductLabel,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabel')));
        }
        return handle;
    }


  /**
   * Update label batch data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelBatchByMap(
    map: UpdateProductLabelBatch.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelBatchByMap(
    map: UpdateProductLabelBatch.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelBatchByMap(
    map: UpdateProductLabelBatch.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelBatchByMap(
    map: UpdateProductLabelBatch.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelBatch(
      map.ApiProductLabelBatch,
      observe,
      reportProgress
    );
  }


    /**
     * Update label batch data
     * 
     * @param ApiProductLabelBatch 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelBatch(ApiProductLabelBatch: ApiProductLabelBatch, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelBatch === null || ApiProductLabelBatch === undefined) {
            throw new Error('Required parameter ApiProductLabelBatch was null or undefined when calling updateProductLabelBatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label_batch`,
            ApiProductLabelBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelBatch')));
        }
        return handle;
    }


  /**
   * Update label content by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelContentByMap(
    map: UpdateProductLabelContent.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelContentByMap(
    map: UpdateProductLabelContent.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelContentByMap(
    map: UpdateProductLabelContent.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelContentByMap(
    map: UpdateProductLabelContent.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelContent(
      map.ApiProductLabelContent,
      observe,
      reportProgress
    );
  }


    /**
     * Update label content
     * 
     * @param ApiProductLabelContent 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelContent(ApiProductLabelContent: ApiProductLabelContent, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelContent(ApiProductLabelContent: ApiProductLabelContent, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelContent(ApiProductLabelContent: ApiProductLabelContent, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelContent(ApiProductLabelContent: ApiProductLabelContent, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelContent === null || ApiProductLabelContent === undefined) {
            throw new Error('Required parameter ApiProductLabelContent was null or undefined when calling updateProductLabelContent.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/content`,
            ApiProductLabelContent,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelContent')));
        }
        return handle;
    }


  /**
   * Update field values by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelValuesByMap(
    map: UpdateProductLabelValues.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelValuesByMap(
    map: UpdateProductLabelValues.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelValuesByMap(
    map: UpdateProductLabelValues.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelValuesByMap(
    map: UpdateProductLabelValues.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelValues(
      map.ApiProductLabelUpdateValues,
      observe,
      reportProgress
    );
  }


    /**
     * Update field values
     * 
     * @param ApiProductLabelUpdateValues 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelValues(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelValues(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelValues(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelValues(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelUpdateValues === null || ApiProductLabelUpdateValues === undefined) {
            throw new Error('Required parameter ApiProductLabelUpdateValues was null or undefined when calling updateProductLabelValues.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/values`,
            ApiProductLabelUpdateValues,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelValues')));
        }
        return handle;
    }

}
